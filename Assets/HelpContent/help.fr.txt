## 1) Qu’est‑ce que c’est et pourquoi
DevProjex prépare rapidement le contexte d’un projet : affiche la structure dossiers/fichiers, permet de sélectionner des éléments et de copier l’arborescence et/ou le contenu des fichiers dans le presse‑papiers. Utile pour code review, support, formation et partage de structure avec un assistant IA.

Important : l’application est en lecture seule et ne modifie jamais les fichiers.

## 2) Arborescence du projet
* Icônes de type fichier/dossier.
* Cases à cocher sur les nœuds.
* Déplier/replier.

Cases à cocher : cocher un nœud s’applique aux enfants ; l’état des parents se recalculent automatiquement.

Raccourcis :
* Ctrl+E — tout déplier
* Ctrl+W — tout replier (la racine reste ouverte)

## 3) Fichier
* Ouvrir le dossier… — ouvrir le dossier racine (Ctrl+O)
* Actualiser — relire et reconstruire l’arborescence (F5)
* Exporter vers un fichier :
  * Exporter l’arborescence
  * Exporter le contenu
  * Exporter arborescence et contenu

Règles de format :
* Exporter l’arborescence :
  * ASCII -> uniquement `.txt`.
  * JSON -> `.json` par défaut, avec `.json` et `.txt` disponibles dans la boîte de sauvegarde.
* Exporter le contenu — toujours au format texte du contenu, fichier `.txt` (le sélecteur ASCII/JSON n’influence pas).
* Exporter arborescence et contenu — toujours fichier `.txt` ; le sélecteur ASCII/JSON n’influence que le format du bloc arborescence dans le résultat.

Les fichiers exportés sont écrits en UTF-8 sans BOM.

### Drag & Drop
Le glisser-déposer fonctionne dans la zone de démarrage (Drop Zone) quand aucun projet n’est chargé.

Règles :
* vous pouvez déposer un dossier ;
* vous pouvez déposer un fichier — dans ce cas, le dossier contenant ce fichier est ouvert ;
* si plusieurs éléments sont déposés, le premier chemin local valide est utilisé ;
* si un chemin est indisponible ou inexistant, les mêmes vérifications d’accès que pour « Ouvrir le dossier… » sont appliquées ;
* les éléments non pris en charge ou non locaux sont ignorés.

## 4) Git
Le menu Git n’est disponible que pour les projets clonés via DevProjex (Git Clone). L’application ne touche pas à vos fichiers — elle travaille uniquement avec le cache.

Le cache est stocké dans le dossier temporaire du système. Sous Windows, c’est généralement :
`%TEMP%\DevProjex\RepoCache`

* Branche — affiche la liste des branches disponibles avec indication de la branche active ; le changement met à jour l’arborescence sur la branche choisie. Si la branche existe déjà en local, le changement se fait hors ligne (sans mise à jour). Si elle n’existe pas localement, elle est récupérée (fetch) et créée localement.
* Obtenir les mises à jour — met à jour uniquement la branche courante : fetch et reset vers origin/<branche>.

## 5) Copier
### Sélecteur de format de l’arborescence (ASCII/JSON)
Le sélecteur définit le format de représentation de l’arborescence pour les opérations où l’arbre participe au résultat.

* ASCII — arborescence textuelle avec branches.
* JSON — arborescence structurée en JSON.

Le sélecteur influence :
* Copier l’arborescence
* Copier l’arborescence + le contenu
* Exporter l’arborescence
* Exporter arborescence et contenu

Le sélecteur n’influence pas :
* Copier le contenu
* Exporter le contenu

### Copier l’arborescence
Copie l’arborescence du projet.
S’il y a des nœuds cochés, l’arborescence est construite à partir de la sélection ; si la sélection est vide ou invalide, l’arborescence complète est copiée.
Le format du résultat est défini par le sélecteur ASCII/JSON.
Raccourcis : Ctrl+Shift+C et Ctrl+Alt+C.

### Copier le contenu
Copie le contenu des fichiers :
* si des fichiers sont cochés — seuls ceux-ci ; sinon — tous les fichiers du projet ;
* les fichiers non textuels sont ignorés (y compris les binaires) ;
* pour les fichiers texte vides, le chemin et la ligne `[No Content, 0 bytes]` sont ajoutés ;
* pour les fichiers ne contenant que des espaces/retours à la ligne, le chemin et la ligne `[Whitespace, N bytes]` sont ajoutés.
Raccourci : Ctrl+Alt+V.

### Copier l’arborescence + le contenu
Combine arborescence et contenu :
* arborescence depuis la sélection ; si la sélection est vide ou invalide, l’arborescence complète est utilisée ;
* contenu selon les mêmes règles que « Copier le contenu » ;
* le format du bloc arborescence est défini par le sélecteur ASCII/JSON.
Raccourci : Ctrl+Shift+V.

### Représentation JSON
Le mode JSON utilise une structure compacte de l’arborescence.

Arborescence (Copier l’arborescence / Exporter l’arborescence) :
* `rootPath` — chemin racine dans le format de sortie actuel :
  * pour un dossier local — chemin local absolu ;
  * pour un projet Git — URL du dépôt.
* `root` — nœud racine.
* champs du nœud : `name`, `path`, `dirs`, `files`, `accessDenied` (si nécessaire).

Arborescence + contenu :
* JSON s’applique au bloc arborescence ;
* le bloc contenu reste textuel ;
* export en `.txt`.

## 6) Mode aperçu
S’ouvre avec le bouton icône œil dans la barre supérieure ou avec Ctrl+B.

Affiche le résultat final en lecture seule, sans copie dans le presse-papiers et sans export vers un fichier.

Modes disponibles :
* Arborescence
* Contenu
* Arborescence et contenu

Les mêmes règles que pour la copie et l’export sont appliquées :
* les nœuds cochés sont pris en compte ;
* si la sélection est vide, l’ensemble complet des données est utilisé ;
* les règles d’ignorance et les paramètres de sélection actuels sont appliqués.

Quand l’aperçu est ouvert, la recherche et le filtre ne sont pas disponibles.
Dans les options, seule la modification de la police est disponible.
Fermeture : bouton X ou nouveau clic sur l’icône œil.

## 7) Affichage
### Zoom
* Ctrl++ / Ctrl+= — agrandir
* Ctrl+- — réduire
* Ctrl+0 — réinitialiser
* Ctrl + molette sur l’arbre et en mode aperçu — zoom fluide

Plage : 6–28, reset : 15.

### Mode compact
Rend l’interface plus dense : moins d’espaces dans l’arbre et les paramètres.

### Animation de l'arborescence
Active une animation de glissement fluide au survol des lignes de l'arborescence.

## 8) Recherche dans l'arbre
Ouvre la recherche, met en évidence les correspondances et permet la navigation.
* Ctrl+F — afficher/masquer
* Enter — résultat suivant
* Shift+Enter — précédent
* Esc — fermer

La recherche n’ouvre que les branches nécessaires ; en effaçant la requête, l’arbre se replie (sauf la racine).

Limitations :
* à l’ouverture de la recherche, le filtre se ferme automatiquement ;
* en mode aperçu, la recherche n’est pas disponible.

## 9) Filtrer par nom
Affiche uniquement les nœuds correspondant au filtre et leurs parents. Mise à jour avec délai (debounce).
* Ctrl+Shift+N — afficher/masquer le filtre
* Esc — fermer le filtre

Limitations :
* à l’ouverture du filtre, la recherche se ferme automatiquement ;
* en mode aperçu, le filtre n’est pas disponible.

## 10) Options
Listes à droite :
* Police de l’arborescence — appliquer avec Appliquer
* Ignorer
* Types de fichiers
* Dossiers de premier niveau

Chaque liste a un bouton Tous.

Remarque sur « Types de fichiers » :
* cette liste affiche uniquement les fichiers avec extension ;
* les fichiers sans extension ne sont pas ajoutés à cette liste et sont gérés par une option séparée dans « Ignorer ».

Ctrl+P — afficher/masquer le panneau.

## 11) Ignorer
La liste « Ignorer » est générée automatiquement à partir du chemin actuel et des dossiers de premier niveau sélectionnés.

Ordre des options :
* Smart ignore (si disponible)
* Utiliser .gitignore (si au moins un `.gitignore` est trouvé)
* Dossiers cachés
* Fichiers cachés
* Dossiers commençant par un point
* Fichiers commençant par un point
* Fichiers sans extension (affiché uniquement si de tels fichiers sont détectés)

La ligne sous « Utiliser .gitignore » sépare les règles Git/Smart des règles de visibilité de base.

### 11.1 Portée des règles
L’application construit des zones de projet (scopes) où les règles d’ignore sont appliquées :
* racine (si la racine contient `.gitignore` ou un marqueur de projet)
* dossiers du premier niveau
* sous-dossiers de projet imbriqués

La profondeur de recherche des zones de projet imbriquées est fixe : 2 niveaux.

### 11.2 « Utiliser .gitignore »
* Activé : les règles `.gitignore` sont appliquées dans les zones détectées.
* Désactivé : les règles `.gitignore` sont entièrement désactivées.

Dans un dossier multi-projets, le `.gitignore` d’un projet ne s’applique pas aux projets voisins hors de sa zone.

### 11.3 « Smart ignore »
* Affiché uniquement lorsqu’il est pertinent.
* Activé : les artefacts courants de build/outils sont masqués en plus.
* Désactivé : les règles smart ne sont pas appliquées.

### 11.4 Règles de base
Options :
* Dossiers cachés
* Fichiers cachés
* Dossiers commençant par un point
* Fichiers commençant par un point

Ces règles sont indépendantes de `.gitignore` et Smart Ignore et dépendent uniquement de leurs propres interrupteurs.

### 11.5 Fonctionnement interne : cas typiques
1. Projet unique avec `.gitignore`.
En général, seule l’option « Utiliser .gitignore » est affichée.
Quand elle est activée, `.gitignore` et Smart Ignore fonctionnent ensemble.
Quand elle est désactivée, les deux sont désactivés.

2. Projet unique sans `.gitignore`.
« Utiliser .gitignore » n’est pas affiché.
« Smart ignore » n’est affiché que s’il est pertinent.

3. Espace multi-projets, certains projets ont `.gitignore`, d’autres non.
« Utiliser .gitignore » et « Smart ignore » sont affichés.
`.gitignore` agit dans sa propre zone.
Smart Ignore (s’il est activé) complète le filtrage dans les zones détectées.

4. Espace multi-projets, tous les projets ont `.gitignore`.
« Utiliser .gitignore » est affiché.
« Smart ignore » n’est pas affiché comme option séparée.

5. Dossier sans règles pertinentes.
Si aucun `.gitignore` n’est trouvé et que Smart Ignore n’est pas pertinent, ces options sont masquées.
Seules les règles de visibilité de base restent actives.

### 11.6 Fichiers sans extension
L’option « Fichiers sans extension » contrôle l’affichage des fichiers sans extension (par exemple : `Dockerfile`, `Makefile`, `README`).

Règles :
* cette option est affichée uniquement si de tels fichiers existent réellement dans l’ensemble de données courant ;
* lorsqu’elle est activée, les fichiers sans extension sont exclus de l’arbre et des opérations de copie/export ;
* lorsqu’elle est désactivée, les fichiers sans extension sont inclus dans le résultat ;
* la liste « Types de fichiers » n’influence pas ce mécanisme.
## 12) Comment l’arbre et les métriques sont calculés
Le résultat dépend de :
* dossiers de premier niveau sélectionnés
* types de fichiers sélectionnés
* règles d’exclusion
* filtre actif
* nœuds cochés dans l’arbre (pour les opérations basées sur la sélection)

Si l’accès est refusé, le nœud est marqué Accès refusé.

### 12.1 Ce que montrent les compteurs de la barre d’état
La barre d’état contient deux blocs :
* Arbre — métriques de la sortie texte de l’arborescence ;
* Contenu — métriques de la sortie de contenu des fichiers.

Format :
* Lignes
* Caractères
* ~Tokens (approximation)

Les grandes valeurs sont affichées en format compact (K/M).

Important :
* « Lignes » dans le bloc « Arbre » correspond au nombre de lignes de la représentation finale de l’arborescence, et non au nombre de fichiers sur le disque ;
* cette valeur inclut les dossiers, les fichiers et les éléments techniques de l’arbre (par exemple, les nœuds avec accès refusé).

### 12.2 Comment les métriques sont calculées
Métriques de l’arbre :
* sont calculées à partir de la sortie réelle de l’arbre générée par le même pipeline d’export ;
* respectent le format ASCII/JSON courant.

Métriques du contenu :
* suivent les mêmes règles que la copie/export du contenu ;
* les fichiers binaires sont exclus ;
* les fichiers vides et uniquement blancs sont comptés via des marqueurs de service (`[No Content, 0 bytes]`, `[Whitespace, N bytes]`).

### 12.3 Quand les compteurs sont mis à jour
Le recalcul est effectué :
* après ouverture/actualisation d’un projet ;
* après application des paramètres (ignore, types de fichiers, dossiers racine) ;
* lors des changements de cases à cocher dans l’arbre (avec debounce) ;
* lors du basculement ASCII/JSON (pour les opérations utilisant l’arbre).
* si le calcul en arrière-plan est annulé, les compteurs sont remis à 0 jusqu’au prochain recalcul terminé.

## 13) Icônes
Ordre de sélection :
1) type de nœud (dossier/fichier)
2) nom exact (s’il existe une règle)
3) extension
4) sinon — inconnu

## 14) Thème et effets
Le popover de thème permet :
* thème clair/sombre
* Transparent / Mica / Acrylic
* intensité, flou, contraste, bordures

Les éléments [Beta] peuvent évoluer entre versions.

## 15) Aide → À propos
Ouvre un popover avec les infos de l’app et un lien vers le dépôt.
Réinitialiser les paramètres (Aide → Réinitialiser les paramètres) réinitialise uniquement les paramètres visuels de l’interface (thème, effets, mode compact, animation de l'arborescence) et ne modifie pas les données du projet.
* Esc — fermer le popover

## 16) Langues
La langue se choisit via le menu Langue.

## 17) Barre de progression et annulation
La partie centrale de la barre d’état affiche l’opération active et sa progression.

Modes de progression :
* Indeterminate — sans pourcentage (durée inconnue).
* Determinate — avec pourcentage (0–100).

Comportement :
* pendant le calcul de données en arrière-plan, une progression en pourcentage est affichée ;
* pour certaines opérations Git, le pourcentage est affiché si la source de progression le fournit ;
* pour les opérations très rapides, la progression peut n’apparaître que brièvement.

Bouton X (annuler) dans la barre d’état :
* exécute une annulation best-effort pour les opérations qui prennent en charge l’annulation ;
* arrête le calcul de données en arrière-plan ;
* pour les opérations sans prise en charge de l’annulation, arrête l’indication dans la barre d’état, tandis que l’opération peut se terminer en arrière-plan.

## 18) Notes
* Par défaut, le thème sombre et les effets de transparence sont activés (si supportés).
* Si les permissions sont insuffisantes, l’app peut proposer un redémarrage avec élévation ; sinon un avertissement s’affiche.
